There is a large list of sources for most of this that are not cited here, I did not record my adventures through the stack overflow rabbit hole.

* Windows
*Note:* MSYS2 is attempted first, if it fails, then WSL is attempted... you must have atleast one setup according to the below instructions
** Windows with MSYS2
*** Installing GPG4Win, Putty, and Git For Windows
Open Kleopatra, enable ssh support and putty support by opening

Settings->configure kleopatra->GnuPG System->Private Keys->
{enable ssh support & enable putty support}->Apply

my gpg-agent.conf looks like this at the time of writing, the top two lines must exist in your conf
#+begin_src shell
enable-putty-support
enable-ssh-support
use-standard-socket
default-cache-ttl 600
max-cache-ttl 7200
#+end_src

insure that putty binaries are on your PATH.

Set global git config

remotes should be configured with your gpg signing key, and gpg auth key as ssh-key
#+begin_src shell
git config --global gpg.program #<path to GPG4Win gpg.exe>
git config --global commit.gpgsign true
git config --global user.signingkey #<your gpg fingerprint>
git config --global core.sshcommand "plink -agent"
git config --global user.email #<your email here>
git config --global user.name #"<your name here>"
git config --global core.editor #<preferred editor here>
#+end_src
*** my bash_profile
#+begin_src shell
# generated by Git for Windows
test -f ~/.profile && . ~/.profile
test -f ~/.bashrc && . ~/.bashrc

# removes paths with spaces
# with awk is copied from http://stackoverflow.com/a/370192.
if [ $(uname -o) == 'Msys' ]; then
    export PATH=`echo ${PATH} | awk -v RS=: -v ORS=: '/c\// {next} {print}' | sed 's/:*$//'`
fi

#insures path uses the gpg4win gpg.exe binary
export PATH=/c/tools/gpg/GnuPG/bin:$PATH
#+end_src
*** my bashrc
Using pacman
install pass
install winpty

the alias gpgw is only used within msys2 shell to communicate with gpg.exe

/Info:/ if you remove the "echo -ne" line the passff.py file can be modified to not create a temporary rcfile. Passff was unable to strip all ansi escape characters and would fail otherwise.
#+begin_src shell
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi
export GNUPGHOME=~/.gnupg

# Don't wait for job termination notification
set -o notify

# Enables UTF-8 in Putty.
# See http://www.earth.li/~huggie/blog/tech/mobile/putty-utf-8-trick.html
echo -ne '\e%G\e[?47h\e%G\e[?47l'

alias gpgw='winpty -- gpg'

function start_gpg_agent()
{
    # Make sure that the gpg-agent is running since ssh-pageant does not know how to start it.
    gpgconf --launch gpg-agent
    # Start ssh-pageant, use -r to reuse the "socket" if it exists.
    eval $(ssh-pageant -r -a "/tmp/S.ssh-pageant.$USERNAME") > /dev/null
}
[ -z "$SSH_CONNECTION" ] && start_gpg_agent
#+end_src

** Windows with WSL - Debian based
/Info:/ I got this working with wsl before msys, so these are copied steps from previous work. It should work, but is untested with this repos passff.py... raise an issue if it doesnt work and I'll look into it.
Install gtk pinentry
#+begin_src shell
sudo apt-get install pinentry-gtk-2
#+end_src
Custom pinentry script - place in /usr/local/bin/{scriptname}
[[https://a3nm.net/git/mybin/file/my-pinentry.html][source]]
#+begin_src shell
#!/bin/bash

  case $PINENTRY_USER_DATA in
  gtk)
   exec /usr/bin/pinentry-gtk-2 "$@"
   ;;
  none)
   exit 1
   ;;
  ,*)
   exec /usr/bin/pinentry-curses "$@"
  esac

#+end_src
Setup gpg confs

/NOTE: the pinentry-program line, modify it to match your pinentry script path/
#+begin_src shell
use-standard-socket
pinentry-program /usr/local/bin/{your-custom-pinentry-script}
allow-loopback-pinentry
#+end_src

Add these lines to your .bashrc

/Note - if you add any calls to powershell to use in bash, strip the carriage return with tr/
#+begin_src shell
#this exit function works most of the time, ymmv.
function on_exit(){
if [[ $(cat /proc/version) == *microsoft* ]]
then
WSL_COUNT=$(tr -d "\r" <<< $(powershell.exe -Command "(get-process -erroraction 'silentlycontinue' wsl).Count"))
 if [[ $WSL_COUNT -eq 1 ]]
  then 
  powershell.exe -Command 'If ((get-process "vcxsrv" -ea SilentlyContinue) -eq $NULL){1}ELSE{stop-process (get-process "vcxsrv").Id}'
  fi
fi
}

trap on_exit EXIT

#+end_src

Add this to bashrc. It checks if the distro is in wsl, then checks if the xserver is running. If it is it skips, otherwise it starts it. I have this at the top of my bashrc.

#+begin_src shell
if [[ $(cat /proc/version) == *microsoft* ]]
then
 is_xsrv_running=$(powershell.exe -Command '$(If ((get-process "vcxsrv" -ea SilentlyContinue) -eq $NULL){1}ELSE{0})' | tr -d '\r')
 HOST=$(ip address show dev eth0 | awk -F '[ /]+' '/inet / { print $3 }')
 export DISPLAY=127.0.0.1:0
 export WSLENV="$WSLENV:DISPLAY"
 if [ $is_xsrv_running == "1" ]
 then
  powershell.exe -Command '& "C:\Program Files\VcXsrv\vcxsrv.exe" -multiwindow -wgl'
  powershell.exe -Command '& "C:\Program Files\VcXsrv\xhost.exe" '+$HOST 
 fi 
export DISPLAY=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf 2>/dev/null):0
 export LIBGL_ALWAYS_INDIRECT=1
fi

#+end_src

Add these to bashrc. They set up env vars for gpg in a wsl context. Otherwise it assumes use of curses.

#+begin_src shell
GPG_TTY=$(tty)
export GPG_TTY
if [[ $(cat /proc/version) == *microsoft* ]]
then
export PINENTRY_USER_DATA="gtk" #if we are in wsl, then use gui w/gtk
else
export PINENTRY_USER_DATA="curses" #else use the terminal
fi
#+end_src
